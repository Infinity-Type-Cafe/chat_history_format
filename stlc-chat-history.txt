lollipop 14:02
期待，我就是小白
maplgebra 14:06
大家有问题可以直接在聊天框里问，如果需要开麦，有人会给你专门开麦
灯夜 14:07
我一直不太理解，相继式演算和蕴涵的区别
面皮 14:11
如果你能区分 judgement 和 proposition，那类似地就能区分相继式演算和蕴涵，也就是元语言与目标语言的区别，我们用相继式演算中的分数线语法J1/J2作为元语言来做推理，而蕴含是目标语言中的被推理的部分 P=>Q
小大圣 14:14
就是推理的方法和一个箭头符号的区别
SnowOnion 14:15
感觉此处不必提「相继式演算」，提「Judgement」就行了……「Judgement=Premise(s)+Conclusion+Name」
灯夜 14:15
谢谢，也就是说，相继式演算是元语言的规则，用于描述目标语言。蕴涵是目标语言的符号
灯夜 14:16
（啊，熟人发现）
maplgebra 14:17
提醒一下，本次会议字幕是可以打开的，如果大家有需求的话
oCaU 14:18
Var这个规则在一阶逻辑中也类似。Γ 是公理集，[表情]表示可证，Var这个规则表示公理集里的句子可证
SnowOnion 14:20
勘误: A->B->C = A->(B->C)
SnowOnion 14:20
-> 右结合，函数应用左结合（（（
灯夜 14:30
de brujin?
oCaU 14:32
对
sager 14:32
ijn吧
oCaU 14:37
这个例子有什么语义吗
灯夜 14:42
语境是一个列表，列表最重要的是顺序，那么语境中的项的顺序有什么用呢？
oCaU 14:44
不一定要列表吧
灯夜 14:44
（用栈？）
史豪 14:45
现在大家可以直接开麦问
灯夜 14:45
用栈的话，离开作用域就只需要pop就可以了
小大圣 14:46
栈也是特殊的列表
面皮 14:46
在有依赖关系的时候，顺序matters
oCaU 14:46
数学上就是 Promise 的幂集 Promise [表情] Prop
灯夜 14:46
类型的类型
LXL 14:49
讲义后文有提到模型（第四节）的形式定义不详细给出了，能否给个参考文献/给个详细形式定义/或者截图之类的呢？
oCaU 14:50
下一节课会讲吧？
黄行知 14:50
像x ctx 这样的判断是类型论内的语言吗？它看起来和其他的判断不太一样
Caviar-X 14:50
ctx只是为了方便讲而定义的吧
LXL 14:51
（好嘞～那等之后讲好了～(>_<)）
Alias 14:51
Categorical Logic
LXL 14:51
Thx～我查看下～
灯夜 14:53
我看到的例子是printf函数
Caviar-X 14:55
能问一下STLC中允许不定长参数的的lambda函数存在吗
Caviar-X 14:56
谢谢
启源 14:56
Categorical Logic 这本书是哪个作者的, Andrew M. Pitts ?
Alias 14:56
y
灯夜 15:08
看起来像涵子
LXL 15:10
top bottom ans [表情] 以及语境的这六条是模型的定义要求的
还是说只是某个特定的模型(解释)这么定义？
面皮 15:11
某个特定的模型（集合模型）
LXL 15:11
那 是否不同的STLC系统（只要带top bottom ans）的集合模型都要求这六条呢
LXL 15:12
（还是说 依然是某一个集合模型这么设置而已？）
Caviar-X 15:12
某一个集合模型这么设置吧
LXL 15:14
Thx～那我消化一下～：）
LXL 15:15
（所以集合模型的定义具体要求满足哪些规则呢）
浴缸 15:15
可以给出在这个模型里应用函数的例子吗，感谢
LXL 15:16
（我先翻翻categorical logic那本书。。）
LXL 15:20
那么为什么我们得到的是
“ Gamma vdash yes noteq no”
而不是“Gamma not vdash yes eq no”呢
- 15:26
CMake...
oCaU 15:26
强到可证矛盾是吧
苏程浩 15:26
说得好，就爱单类型
kokic 15:27
AQ: 接下来我用 js 写...
Caviar-X 15:28
能问一下如何构造一个 [表情]yes[表情] = [表情]no[表情] 的模型吗
Caviar-X 15:28
对于之前语境中的Ans type
Paro 15:28
不可能构造这样的模型吧
Caviar-X 15:29
全部解释到一个值？
面皮 15:29
因为模型不需要满足并不存在的Ans的消去规则
LXL 15:29
抱歉继续追问刚才的内容（和这个yes=no也相关）
 yes noteq no 似乎应该是对应 (yes eq no) [表情] bottom ?

这样的话 元语言层面的 Gamma not vdash yes eq no似乎不能直接用 Gamma vdash yes noteq no 表示？

（这里Gamma not vdash仅仅指语境Gamma得不到后面的项）

（因为看起来我们是通过一个特定的模型发现在Gamma语境被满足的情况下，yes eq no没被满足，而不是对所有模型都造出了yes eq no [表情] bottom ？）
面皮 15:32
语法是某种自由的东西，而语义（模型）是某个具体的可以额外增加约束的东西，如果某个语义中某个性质不行，那么也就是在语法上单靠纯粹自由的东西，某个性质是推不出来的。例如现在有一个自由的半群，他不一定是群，但群可以是半群的模型（
启源 15:32
计算规则是 computation rule 还是 calculation rule?
面皮 15:32
computation rule
LXL 15:33
所以讲义中的“任何语境下都有 yes noteq ： ans” 其实是指 任何语境下都得不出 yes eq no 对吧？
LXL 15:34
ok 我明白了
Caviar-X 15:35
但是根据之前讲的将yes no映射到同一个值上的解法的话不是和这个冲突吗
LXL 15:35
那个模型的话 应该是 yes=no 不是yes eq no
Caviar-X 15:36
equiv?
LXL 15:36
嗯 equiv
Caviar-X 15:37
哦哦
oCaU 15:37
看起来像η规则
LXL 15:37
（不对 还是听主讲人的）
Paro 15:38
所以 在某一个模型中不成立的命题在语法中也不成立，但是在某一个模型中成立的命题在语法中不一定成立
Caviar-X 15:38
那模型中不是并不存在 yes \nequiv no吗
Caviar-X 15:39
我自己在看看讲义吧
oCaU 15:41
讲义中说是练习
小大圣 15:42
晚上应该还有讨论时间大概（）
韩暮秋 15:42
今晚没有安排习题相关答疑，在明晚
Caviar-X 15:43
能否问一下A+B在elim中决定c_l或c_r的条件吗
Caviar-X 15:43
哦哦
Tesla Zhang 16:00
你也可以说规则有零条
小大圣 16:01
能不能得出所有元素都相等的类型一定是top，没有元素的类型一定是bot
LXL 16:02
（只能同构/相等吧）
114514 16:02
top 和 top 取积类型
114514 16:02
一样的
小大圣 16:03
好的，谢谢
Caviar-X 16:07
传递性
114514 16:10
最好说「可以互相翻译」.
114514 16:12
喔, 这样也可以
ezra 16:14
请问居留对应的英文是什么呢？
oCaU 16:14
inhabit
ezra 16:14
好的谢谢
刘极 16:14
好像以前看Arend的时候，他们还有说不是所有Type还什么的都是Proposition，他们好像还有个性质叫Propositional，我记得里面有个类型叫Props，不过不是很懂就是了
oCaU 16:15
那是HoTT的内容，后面会讲
114514 16:15
@刘极 这个超出这个课的范畴了, 你可以去听同伦类型论的部分, 那个会讲的. 在这里姑且是只有唯一的命题的概念
114514 16:15
Gödel
刘极 16:15
懂了懂了
114514 16:16
说的好!
114514 16:19
很好, 还有总结, 太棒了
114514 16:20
啪啪啪
启源 16:20
papapap
Caviar-X 16:20
谢谢主讲人
Draming 16:21
好
114514 16:21
Draming 是 Dram 吗
Draming 16:21
不是。
ppp 16:22
课中提到的一致性与逻辑中的可靠性(soundness)的意义相似吗
灯夜 16:22
什么是平凡的函数，什么是不平凡的函数？
114514 16:22
一致性是 consistency
114514 16:22
可靠性是 soundness
114514 16:22
一致性是不能推出 False
Hoshino 16:22
stlc 本身可以是一个 stlc 的模型吗
114514 16:23
soundness 是理论里面不能证出不符合模型的定理
灯夜 16:25
用命题的说法：有证明的是平凡的，没有证明的是不平凡的？
114514 16:26
我觉得现在可以开麦对线
114514 16:27
选择比努力更重要!
114514 16:28
其实是很主观的
114514 16:28
你觉得证明不需要动脑子就是平凡的 (
ZHHX 16:29
想问一下类型论和集合论是什么关系，我看base type那里是取了个集合，那是说类型论依赖于集合论吗
oCaU 16:30
集合论依赖于一阶逻辑，一阶逻辑依赖于集合
114514 16:30
类型论可以依赖别的数学基础, 但你总得选一个语言来描述这些对线
面皮 16:30
那就用自然语言当元语言吧！
114514 16:30
东西
114514 16:30
集合论目前是最知名的
114514 16:31
广泛使用, 而且本科数学会教, 所以就用了
ZHHX 16:31
好的
ezra 16:31
元语言通过模型被解释到目标语言
请问上边这句理解有误吗？
114514 16:31
目标语言是模型的一部分
114514 16:31
模型包含了那个解释的过程, 和解释的目标
114514 16:32
其它是对的, 我觉得理解基本正确
ezra 16:32
嗯嗯好的，我再理解下
Y2 16:32
这个stlc能不能定义递归函数之类的东西啊，还是要加入不动点mu的构造
114514 16:33
你可以加, 但加了之后它就不再适合作为逻辑语言, 只能用来做编程语言
面皮 16:33
用 elim_Nat 来构造，可以做原始递归（
启源 16:34
这个 elim 是 primary recursion 吗
Y2 16:34
懂了，谢谢
面皮 16:34
印象中是的
oCaU 16:35
elim跟recursion是有点像，但我也解释不好
启源 16:36
wow
