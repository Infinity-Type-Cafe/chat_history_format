
|
o- 14:02 lollipop 
| 期待,我就是小白
|
o- 14:06 maplgebra 
| 大家有问题可以直接在聊天框里问,如果需要开麦,有人会给你专门开麦
|
o- 14:07 灯夜 
| 我一直不太理解,相继式演算和蕴涵的区别
|
o- 14:11 面皮 
| 如果你能区分 judgement 和 proposition,那类似地就能区分相继式演算和蕴涵,也就是元语言与目标语言的区别,我们用相继式演算中的分数线语法J1/J2作为元语言来做推理,而蕴含是目标语言中的被推理的部分 P=>Q
|
o- 14:14 小大圣 
| 就是推理的方法和一个箭头符号的区别
|
o- 14:15 SnowOnion 
| 感觉此处不必提「相继式演算」,提「Judgement」就行了……「Judgement=Premise(s)+Conclusion+Name」
|
o- 14:15 灯夜 
| 谢谢,也就是说,相继式演算是元语言的规则,用于描述目标语言。蕴涵是目标语言的符号
|
o- 14:16 灯夜 
| (啊,熟人发现)
|
o- 14:17 maplgebra 
| 提醒一下,本次会议字幕是可以打开的,如果大家有需求的话
|
o- 14:18 oCaU 
| Var这个规则在一阶逻辑中也类似。Γ 是公理集,[表情]表示可证,Var这个规则表示公理集里的句子可证
|
o- 14:20 SnowOnion 
| 勘误: A->B->C = A->(B->C)
|
o- 14:20 SnowOnion 
| -> 右结合,函数应用左结合(((
|
o- 14:30 灯夜 
| de brujin?
|
o- 14:32 oCaU 
| 对
|
o- 14:32 sager 
| ijn吧
|
o- 14:37 oCaU 
| 这个例子有什么语义吗
|
o- 14:42 灯夜 
| 语境是一个列表,列表最重要的是顺序,那么语境中的项的顺序有什么用呢?
|
o- 14:44 oCaU 
| 不一定要列表吧
|
o- 14:44 灯夜 
| (用栈?)
|
o- 14:45 史豪 
| 现在大家可以直接开麦问
|
o- 14:45 灯夜 
| 用栈的话,离开作用域就只需要pop就可以了
|
o- 14:46 小大圣 
| 栈也是特殊的列表
|
o- 14:46 面皮 
| 在有依赖关系的时候,顺序matters
|
o- 14:46 oCaU 
| 数学上就是 Promise 的幂集 Promise [表情] Prop
|
o- 14:46 灯夜 
| 类型的类型
|
o- 14:49 LXL 
| 讲义后文有提到模型(第四节)的形式定义不详细给出了,能否给个参考文献/给个详细形式定义/或者截图之类的呢?
|
o- 14:50 oCaU 
| 下一节课会讲吧?
|
o- 14:50 黄行知 
| 像x ctx 这样的判断是类型论内的语言吗?它看起来和其他的判断不太一样
|
o- 14:50 Caviar-X 
| ctx只是为了方便讲而定义的吧
|
o- 14:51 LXL 
| (好嘞~那等之后讲好了~(>_<))
|
o- 14:51 Alias 
| Categorical Logic
|
o- 14:51 LXL 
| Thx~我查看下~
|
o- 14:53 灯夜 
| 我看到的例子是printf函数
|
o- 14:55 Caviar-X 
| 能问一下STLC中允许不定长参数的的lambda函数存在吗
|
o- 14:56 Caviar-X 
| 谢谢
|
o- 14:56 启源 
| Categorical Logic 这本书是哪个作者的, Andrew M. Pitts ?
|
o- 14:56 Alias 
| y
|
o- 15:08 灯夜 
| 看起来像涵子
|
o- 15:10 LXL 
| top bottom ans [表情] 以及语境的这六条是模型的定义要求的
| 还是说只是某个特定的模型(解释)这么定义?
|
o- 15:11 面皮 
| 某个特定的模型(集合模型)
|
o- 15:11 LXL 
| 那 是否不同的STLC系统(只要带top bottom ans)的集合模型都要求这六条呢
|
o- 15:12 LXL 
| (还是说 依然是某一个集合模型这么设置而已?)
|
o- 15:12 Caviar-X 
| 某一个集合模型这么设置吧
|
o- 15:14 LXL 
| Thx~那我消化一下~:)
|
o- 15:15 LXL 
| (所以集合模型的定义具体要求满足哪些规则呢)
|
o- 15:15 浴缸 
| 可以给出在这个模型里应用函数的例子吗,感谢
|
o- 15:16 LXL 
| (我先翻翻categorical logic那本书。。)
|
o- 15:20 LXL 
| 那么为什么我们得到的是
| “ Gamma vdash yes noteq no”
| 而不是“Gamma not vdash yes eq no”呢
|
o- 15:26 - 
| CMake...
|
o- 15:26 oCaU 
| 强到可证矛盾是吧
|
o- 15:26 苏程浩 
| 说得好,就爱单类型
|
o- 15:27 kokic 
| AQ: 接下来我用 js 写...
|
o- 15:28 Caviar-X 
| 能问一下如何构造一个 [表情]yes[表情] = [表情]no[表情] 的模型吗
|
o- 15:28 Caviar-X 
| 对于之前语境中的Ans type
|
o- 15:28 Paro 
| 不可能构造这样的模型吧
|
o- 15:29 Caviar-X 
| 全部解释到一个值?
|
o- 15:29 面皮 
| 因为模型不需要满足并不存在的Ans的消去规则
|
o- 15:29 LXL 
| 抱歉继续追问刚才的内容(和这个yes=no也相关)
| yes noteq no 似乎应该是对应 (yes eq no) [表情] bottom ?
| 
| 这样的话 元语言层面的 Gamma not vdash yes eq no似乎不能直接用 Gamma vdash yes noteq no 表示?
| 
| (这里Gamma not vdash仅仅指语境Gamma得不到后面的项)
| 
| (因为看起来我们是通过一个特定的模型发现在Gamma语境被满足的情况下,yes eq no没被满足,而不是对所有模型都造出了yes eq no [表情] bottom ?)
|
o- 15:32 面皮 
| 语法是某种自由的东西,而语义(模型)是某个具体的可以额外增加约束的东西,如果某个语义中某个性质不行,那么也就是在语法上单靠纯粹自由的东西,某个性质是推不出来的。例如现在有一个自由的半群,他不一定是群,但群可以是半群的模型(
|
o- 15:32 启源 
| 计算规则是 computation rule 还是 calculation rule?
|
o- 15:32 面皮 
| computation rule
|
o- 15:33 LXL 
| 所以讲义中的“任何语境下都有 yes noteq : ans” 其实是指 任何语境下都得不出 yes eq no 对吧?
|
o- 15:34 LXL 
| ok 我明白了
|
o- 15:35 Caviar-X 
| 但是根据之前讲的将yes no映射到同一个值上的解法的话不是和这个冲突吗
|
o- 15:35 LXL 
| 那个模型的话 应该是 yes=no 不是yes eq no
|
o- 15:36 Caviar-X 
| equiv?
|
o- 15:36 LXL 
| 嗯 equiv
|
o- 15:37 Caviar-X 
| 哦哦
|
o- 15:37 oCaU 
| 看起来像η规则
|
o- 15:37 LXL 
| (不对 还是听主讲人的)
|
o- 15:38 Paro 
| 所以 在某一个模型中不成立的命题在语法中也不成立,但是在某一个模型中成立的命题在语法中不一定成立
|
o- 15:38 Caviar-X 
| 那模型中不是并不存在 yes \nequiv no吗
|
o- 15:39 Caviar-X 
| 我自己在看看讲义吧
|
o- 15:41 oCaU 
| 讲义中说是练习
|
o- 15:42 小大圣 
| 晚上应该还有讨论时间大概()
|
o- 15:42 韩暮秋 
| 今晚没有安排习题相关答疑,在明晚
|
o- 15:43 Caviar-X 
| 能否问一下A+B在elim中决定c_l或c_r的条件吗
|
o- 15:43 Caviar-X 
| 哦哦
|
o- 16:00 Tesla Zhang 
| 你也可以说规则有零条
|
o- 16:01 小大圣 
| 能不能得出所有元素都相等的类型一定是top,没有元素的类型一定是bot
|
o- 16:02 LXL 
| (只能同构/相等吧)
|
o- 16:02 114514 
| top 和 top 取积类型
|
o- 16:02 114514 
| 一样的
|
o- 16:03 小大圣 
| 好的,谢谢
|
o- 16:07 Caviar-X 
| 传递性
|
o- 16:10 114514 
| 最好说「可以互相翻译」.
|
o- 16:12 114514 
| 喔, 这样也可以
|
o- 16:14 ezra 
| 请问居留对应的英文是什么呢?
|
o- 16:14 oCaU 
| inhabit
|
o- 16:14 ezra 
| 好的谢谢
|
o- 16:14 刘极 
| 好像以前看Arend的时候,他们还有说不是所有Type还什么的都是Proposition,他们好像还有个性质叫Propositional,我记得里面有个类型叫Props,不过不是很懂就是了
|
o- 16:15 oCaU 
| 那是HoTT的内容,后面会讲
|
o- 16:15 114514 
| @刘极 这个超出这个课的范畴了, 你可以去听同伦类型论的部分, 那个会讲的. 在这里姑且是只有唯一的命题的概念
|
o- 16:15 114514 
| Gödel
|
o- 16:15 刘极 
| 懂了懂了
|
o- 16:16 114514 
| 说的好!
|
o- 16:19 114514 
| 很好, 还有总结, 太棒了
|
o- 16:20 114514 
| 啪啪啪
|
o- 16:20 启源 
| papapap
|
o- 16:20 Caviar-X 
| 谢谢主讲人
|
o- 16:21 Draming 
| 好
|
o- 16:21 114514 
| Draming 是 Dram 吗
|
o- 16:21 Draming 
| 不是。
|
o- 16:22 ppp 
| 课中提到的一致性与逻辑中的可靠性(soundness)的意义相似吗
|
o- 16:22 灯夜 
| 什么是平凡的函数,什么是不平凡的函数?
|
o- 16:22 114514 
| 一致性是 consistency
|
o- 16:22 114514 
| 可靠性是 soundness
|
o- 16:22 114514 
| 一致性是不能推出 False
|
o- 16:22 Hoshino 
| stlc 本身可以是一个 stlc 的模型吗
|
o- 16:23 114514 
| soundness 是理论里面不能证出不符合模型的定理
|
o- 16:25 灯夜 
| 用命题的说法:有证明的是平凡的,没有证明的是不平凡的?
|
o- 16:26 114514 
| 我觉得现在可以开麦对线
|
o- 16:27 114514 
| 选择比努力更重要!
|
o- 16:28 114514 
| 其实是很主观的
|
o- 16:28 114514 
| 你觉得证明不需要动脑子就是平凡的 (
|
o- 16:29 ZHHX 
| 想问一下类型论和集合论是什么关系,我看base type那里是取了个集合,那是说类型论依赖于集合论吗
|
o- 16:30 oCaU 
| 集合论依赖于一阶逻辑,一阶逻辑依赖于集合
|
o- 16:30 114514 
| 类型论可以依赖别的数学基础, 但你总得选一个语言来描述这些对线
|
o- 16:30 面皮 
| 那就用自然语言当元语言吧!
|
o- 16:30 114514 
| 东西
|
o- 16:30 114514 
| 集合论目前是最知名的
|
o- 16:31 114514 
| 广泛使用, 而且本科数学会教, 所以就用了
|
o- 16:31 ZHHX 
| 好的
|
o- 16:31 ezra 
| 元语言通过模型被解释到目标语言
| 请问上边这句理解有误吗?
|
o- 16:31 114514 
| 目标语言是模型的一部分
|
o- 16:31 114514 
| 模型包含了那个解释的过程, 和解释的目标
|
o- 16:32 114514 
| 其它是对的, 我觉得理解基本正确
|
o- 16:32 ezra 
| 嗯嗯好的,我再理解下
|
o- 16:32 Y2 
| 这个stlc能不能定义递归函数之类的东西啊,还是要加入不动点mu的构造
|
o- 16:33 114514 
| 你可以加, 但加了之后它就不再适合作为逻辑语言, 只能用来做编程语言
|
o- 16:33 面皮 
| 用 elim_Nat 来构造,可以做原始递归(
|
o- 16:34 启源 
| 这个 elim 是 primary recursion 吗
|
o- 16:34 Y2 
| 懂了,谢谢
|
o- 16:34 面皮 
| 印象中是的
|
o- 16:35 oCaU 
| elim跟recursion是有点像,但我也解释不好
|
o- 16:36 启源 
| wow