
| 2023/7/6
|
o- 20:15 LXL 
| plfa选 “0[表情]n” 和“n[表情]n [表情] suc m [表情] suc n”有啥特殊考量不。。
| (例如没选 “n[表情]n”和“n[表情]m [表情]n[表情] suc m”,是“碰巧”这么选的么~)
|
o- 20:16 LXL 
| (噢。。看来有反演方面的考虑?。。)
|
o- 20:23 灯夜 
| 反对称我记得好像是: R(x, y) => not R(y, x)
|
o- 20:25 LXL 
| (有些地方把灯夜你说这个叫 禁对称)
|
o- 20:25 LXL 
| (这个蕴含了禁自反/反自反)
|
o- 20:30 114514 
| 感觉都是等价的, Agda 标准库的思路是定义了三个版本
|
o- 20:31 114514 
| 然后该用用
|
o- 20:34 114514 
| 讲不讲 ind-rec?
|
o- 20:37 PC 
| 类似交叉递归是吧
|
o- 20:45 maplgebra 
| refl refl refl J规则真的抽象
|
o- 20:45 114514 
| 替换
|
o- 20:45 114514 
| 这个是 HEP
|
o- 20:45 114514 
| HLP
|
o- 20:46 114514 
| 说错了,  homotopy lifting property
|
o- 20:47 114514 
| 我觉得这些可以直接看怎么用
|
o- 20:47 maplgebra 
| 没有人疑惑这里为什么能直接用refl吗
|
o- 20:48 114514 
| Church encoding
|
o- 20:58 hap 
| plfa是什么缩写)
|
o- 20:58 114514 
| subst
|
o- 20:58 uwagjaynoi 
| Programming Language Foundations in Agda
|
o- 20:59 hap 
| thx
|
o- 21:01 灯夜 
| 还没做完
|
o- 21:02 数学主义 
| 昨天那个乘方定义的习题,我照抄自然语言,结果不行,发现要把 1+n 换成 suc n 才行,为什么呢?
|
o- 21:03 数学主义 
| 是的
|
o- 21:05 maplgebra 
| 可以把代码发出来看看
|
o- 21:06 数学主义 
| 尴尬,我这个腾讯会议在虚拟机里
|
o- 21:06 LXL 
| (手机拍照发群里?)
|
o- 21:07 数学主义 
| 算了,我手写一下吧
|
o- 21:07 114514 
| 可能你的加法是对第二个参数模式匹配的
|
o- 21:07 114514 
| 那你就写 n+
|
o- 21:07 114514 
| n+1
|
o- 21:08 114514 
| 那我也不懂了..
|
o- 21:08 数学主义 
| _^_ : N \to N \to N
| m ^ 0 = 1
| m ^ (1 + n) = m * (m ^ n)
|
o- 21:09 数学主义 
| 是这样的
|
o- 21:09 114514 
| 模式匹配必须用构造子写
|
o- 21:09 LXL 
| 模式识别不对吧 suc是constructor吧 1+n不是吧
|
o- 21:09 114514 
| 模式匹配必须用构造子写
|
o- 21:10 maplgebra 
| 等式左边不能出现函数
|
o- 21:10 maplgebra 
| 不是说不能吗 怕停机检查过不了?
|
o- 21:11 数学主义 
| 明白了,谢谢!
|
o- 21:11 灯夜 
| 1 * n = n是LeftIdentity还是RightIdentity?我找不到这个东西的定义
|
o- 21:12 灯夜 
| 我也就是没翻到
|
o- 21:14 灯夜 
| got
|
o- 21:15 Wtz_LASR 
| 非常坏[表情]
|
o- 21:15 Wtz_LASR 
| LMAO
|
o- 21:19 114514 
| with
|
o- 21:20 114514 
| inspect
|
o- 21:20 114514 
| with xxx as p
|
o- 21:21 114514 
| in
|
o- 21:23 114514 
| Cubical.Data.Equality